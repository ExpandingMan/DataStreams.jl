<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="no-js ie6"><![endif]-->
<!--[if IE 7 ]><html class="no-js ie7"><![endif]-->
<!--[if IE 8 ]><html class="no-js ie8"><![endif]-->
<!--[if IE 9 ]><html class="no-js ie9"><![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html class="no-js"> <!--<![endif]-->
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    
      
        <title>DataStreams.jl - DataStreams framework</title>
      
      
        <meta name="description" content="DataStreams framework">
      
      
      
        <meta name="author" content="Jacob Quinn">
      
    
    <meta property="og:url" content="None">
    <meta property="og:title" content="DataStreams.jl">
    <meta property="og:image" content="None/./">
    <meta name="apple-mobile-web-app-title" content="DataStreams.jl">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    
    <link rel="shortcut icon" type="image/x-icon" href="./assets/images/favicon-e565ddfa3b.ico">
    <link rel="icon" type="image/x-icon" href="./assets/images/favicon-e565ddfa3b.ico">
    <style>
      @font-face {
      	font-family: 'Icon';
      	src: url('./assets/fonts/icon.eot?52m981');
      	src: url('./assets/fonts/icon.eot?#iefix52m981')
               format('embedded-opentype'),
      		   url('./assets/fonts/icon.woff?52m981')
               format('woff'),
      		   url('./assets/fonts/icon.ttf?52m981')
               format('truetype'),
      		   url('./assets/fonts/icon.svg?52m981#icon')
               format('svg');
      	font-weight: normal;
      	font-style: normal;
      }
    </style>
    <link rel="stylesheet" href="./assets/stylesheets/application-a422ff04cc.css">
    
      <link rel="stylesheet" href="./assets/stylesheets/palettes-05ab2406df.css">
    
    
      
      
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,700|Ubuntu+Mono">
      <style>
        body, input {
          font-family: 'Ubuntu', Helvetica, Arial, sans-serif;
        }
        pre, code {
          font-family: 'Ubuntu Mono', 'Courier New', 'Courier', monospace;
        }
      </style>
    
    
      <link rel="stylesheet" href="./assets/Documenter.css">
    
    <script src="./assets/javascripts/modernizr-4ab42b99fd.js"></script>
    
  </head>
  
  
  
  <body class="palette-primary-indigo palette-accent-blue">
    
      
      
    
    <div class="backdrop">
      <div class="backdrop-paper"></div>
    </div>
    <input class="toggle" type="checkbox" id="toggle-drawer">
    <input class="toggle" type="checkbox" id="toggle-search">
    <label class="toggle-button overlay" for="toggle-drawer"></label>
    <header class="header">
      <nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        
          <span class="path">
            
          </span>
        
        DataStreams.jl
      </div>
    </div>
    
    
    <div class="button button-search" role="button" aria-label="Search">
      <label class="toggle-button icon icon-search" title="Search" for="toggle-search"></label>
    </div>
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
    </header>
    <main class="main">
      
      <div class="drawer">
        <nav aria-label="Navigation">
  
  <a href="https://github.com/JuliaData/DataStreams.jl" class="project">
    <div class="banner">
      
      <div class="name">
        <strong>
          DataStreams.jl
          <span class="version">
            
          </span>
        </strong>
        
          <br>
          JuliaData/DataStreams.jl
        
      </div>
    </div>
  </a>
  <div class="scrollable">
    <div class="wrapper">
      
        <ul class="repo">
          <li class="repo-download">
            
            <a href="https://github.com/JuliaData/DataStreams.jl/archive/master.zip" target="_blank" title="Download" data-action="download">
              <i class="icon icon-download"></i> Download
            </a>
          </li>
          <li class="repo-stars">
            <a href="https://github.com/JuliaData/DataStreams.jl/stargazers" target="_blank" title="Stargazers" data-action="star">
              <i class="icon icon-star"></i> Stars
              <span class="count">&ndash;</span>
            </a>
          </li>
        </ul>
        <hr>
      
      <div class="toc">
        <ul>
          
            
  <li>
    <a class="current" title="Home" href=".">
      Home
    </a>
    
      
        
      
      
        <ul>
          
            <li class="anchor">
              <a title="Data.Source Interface" href="#datasource-interface">
                Data.Source Interface
              </a>
            </li>
          
            <li class="anchor">
              <a title="Data.Sink Interface" href="#datasink-interface">
                Data.Sink Interface
              </a>
            </li>
          
            <li class="anchor">
              <a title="Data.Schema" href="#dataschema">
                Data.Schema
              </a>
            </li>
          
        </ul>
      
    
  </li>

          
        </ul>
        
      </div>
    </div>
  </div>
</nav>
      </div>
      <article class="article">
        <div class="wrapper">
          
          <p><a id='DataStreams.jl-1'></a></p>
<h1 id="datastreamsjl">DataStreams.jl</h1>
<p>The <code>DataStreams.jl</code> package aims to define a generic and performant framework for the transfer of "table-like" data. (i.e. data that can, at least in some sense, be described by rows and columns).</p>
<p>The framework achieves this by defining interfaces (i.e. a group of methods) for <code>Data.Source</code> types and methods to describe how they "provide" data; as well as <code>Data.Sink</code> types and methods around how they "receive" data. This allows <code>Data.Source</code>s and <code>Data.Sink</code>s to implement their interfaces separately, without needing to be aware of each other. The end result is an ecosystem of packages that "automatically" talk with each other, with adding an additional package not requiring changes to existing packages.</p>
<p>Packages can have a single julia type implement both the <code>Data.Source</code> and <code>Data.Sink</code> interfaces, or two separate types can implement them separately. For examples of interface implementations, see some of the packages below:</p>
<p><code>Data.Source</code> implementations:</p>
<ul>
<li><a href="https://github.com/JuliaData/CSV.jl/blob/master/src/Source.jl"><code>CSV.Source</code></a></li>
<li><a href="https://github.com/JuliaDB/SQLite.jl/blob/master/src/Source.jl"><code>SQLite.Source</code></a></li>
<li><a href="https://github.com/JuliaData/DataStreams.jl/blob/master/src/DataStreams.jl#L251"><code>DataFrame</code></a></li>
<li><a href="https://github.com/JuliaDB/ODBC.jl/blob/master/src/Source.jl"><code>ODBC.Source</code></a></li>
</ul>
<p><code>Data.Sink</code> implementations:</p>
<ul>
<li><a href="https://github.com/JuliaData/CSV.jl/blob/master/src/Sink.jl"><code>CSV.Sink</code></a></li>
<li><a href="https://github.com/JuliaDB/SQLite.jl/blob/master/src/Sink.jl"><code>SQLite.Sink</code></a></li>
<li><a href="https://github.com/JuliaData/DataStreams.jl/blob/master/src/DataStreams.jl#L287"><code>DataFrame</code></a></li>
<li><a href="https://github.com/JuliaDB/ODBC.jl/blob/master/src/Sink.jl"><code>ODBC.Sink</code></a></li>
</ul>
<p><a id='Data.Source-Interface-1'></a></p>
<h2 id="datasource-interface"><code>Data.Source</code> Interface</h2>
<p>The <code>Data.Source</code> interface requires the following definitions, where <code>MyPkg</code> would represent a package wishing to implement the interface:</p>
<ul>
<li><code>Data.schema(::MyPkg.Source) =&gt; Data.Schema</code>; get the <code>Data.Schema</code> of a <code>Data.Source</code>. Typically the <code>Source</code> type will store the <code>Data.Schema</code> directly, but this isn't strictly required. See <code>?Data.Schema</code> or docs below for more information on <code>Data.Schema</code></li>
<li><code>Data.isdone(::MyPkg.Source, row, col) =&gt; Bool</code>; indicates whether the <code>Data.Source</code> will be able to provide a value at a given a <code>row</code> and <code>col</code>.</li>
</ul>
<p>Optional definition:</p>
<ul>
<li><code>Data.reference(::MyPkg.Source) =&gt; Vector{UInt8}</code>; Sometimes, a <code>Source</code> needs the <code>Sink</code> to keep a reference to memory to keep a data structure valid. A <code>Source</code> can implement this method to return a <code>Vector{UInt8}</code> that the <code>Sink</code> will need to handle appropriately.</li>
<li><code>Base.size(::MyPkg.Source[, i]) =&gt; Int</code>; not explicitly required to enable data-streaming, but a <code>Source</code> should generally be able to describe its first 2 dimensions, i.e. # of rows and columns.</li>
</ul>
<p>A <code>Data.Source</code> also needs to "register" the type (or types) of streaming it supports. Currently defined streaming types in the DataStreams framework include:</p>
<ul>
<li><code>Data.Field</code>: a field is the intersection of a specific row and column; this type of streaming will traverse the "table" structure by row, accessing each column on each row</li>
<li><code>Data.Column</code>: this type of streaming will provide entire columns at a time</li>
</ul>
<p>A <code>Data.Source</code> formally supports <strong>field-based</strong> streaming by defining the following:</p>
<ul>
<li><code>Data.streamtype(::Type{MyPkg.Source}, ::Type{Data.Field}) = true</code>; declares that <code>MyPkg.Source</code> supports field-based streaming</li>
<li><code>Data.streamfrom{T}(::MyPkg.Source, ::Type{Data.Field}, ::Type{Nullable{T}}, row, col) =&gt; Nullable{T}</code>; returns a value of type <code>Nullable{T}</code> given a specific <code>row</code> and <code>col</code> from <code>MyPkg.Source</code></li>
<li><code>Data.streamfrom{T}(::MyPkg.Source, ::Type{Data.Field}, ::Type{T}, row, col) =&gt; T</code>; returns a value of type <code>T</code> given a specific <code>row</code> and <code>col</code> from <code>MyPkg.Source</code></li>
</ul>
<p>And for column-based streaming:</p>
<ul>
<li><code>Data.streamtype(::Type{MyPkg.Source}, ::Type{Data.Column}) = true</code></li>
<li><code>Data.streamfrom{T}(::Data.Source, ::Type{Data.Column}, ::Type{T}, col) =&gt; Vector{T}</code>; Given a type <code>T</code>, returns column # <code>col</code> of a <code>Data.Source</code> as a <code>Vector{T}</code></li>
<li><code>Data.streamfrom{T}(::Data.Source, ::Type{Data.Column}, ::Type{Nullable{T}}, col) =&gt; NullableVector{T}</code>; Given a type <code>Nullable{T}</code>, returns column # <code>col</code> of a <code>Data.Source</code> as a <code>NullableVector{T}</code></li>
</ul>
<p><a id='Data.Sink-Interface-1'></a></p>
<h2 id="datasink-interface"><code>Data.Sink</code> Interface</h2>
<p>Similar to a <code>Data.Source</code>, a <code>Data.Sink</code> needs to "register" the types of streaming it supports, it does so through the following definition:</p>
<ul>
<li><code>Data.streamtypes(::Type{MyPkg.Sink}) = [Data.Field[, Data.Column]]</code>; "registers" the streaming preferences for <code>MyPkg.Sink</code>. A <code>Sink</code> type should list the stream type or types it supports. If the <code>Sink</code> supports streaming of multiple types, it should list them in order of preference (i.e. the more natural or performant type first).</li>
</ul>
<p>A <code>Data.Sink</code> needs to also implement specific forms of constructors that ensure proper Sink state in many higher-level streaming functions:</p>
<ul>
<li><code>MyPkg.Sink{T &lt;: Data.StreamType}(schema::Data.Schema, ::Type{T}, append::Bool, ref::Vector{UInt8}, args...; kwargs...)</code>; given a <code>schema::Data.Schema</code> a source will be providing, the type of streaming <code>T</code> (<code>Field</code> or <code>Column</code>), whether the user desires to append the data or not, a possible memory reference <code>ref</code> and any necessary <code>args...</code> and <code>kwargs...</code>, construct an appropriate instance of <code>MyPkg.Sink</code> ready to receive data from <code>source</code>. The <code>append</code> argument allows an already existing sink file/source to "reset" itself if the user does not desire to append.</li>
<li><code>MyPkg.Sink{T &lt;: Data.StreamType}(sink, schema::Data.Schema, ::Type{T}, append::Bool, ref::Vector{UInt8})</code>; similar to above, but instead of constructing a new <code>Sink</code>, an existing <code>Sink</code> is given as a first argument, which may be modified before being returned, ready to receive data according to the <code>Data.Source</code> <code>schema</code>.</li>
</ul>
<p>Similar to <code>Data.Source</code>, a <code>Data.Sink</code> also needs to implement it's own <code>streamto!</code> method that indicates how it receives data.</p>
<p>A <code>Data.Sink</code> supports <strong>field-based</strong> streaming by defining:</p>
<ul>
<li><code>Data.streamto!{T}(sink::MyPkg.Sink, ::Type{Data.Field}, val::T, row, col[, schema])</code>: Given a <code>row</code>, <code>col</code>, and <code>val::T</code> a <code>Data.Sink</code> should store the value appropriately. The type of the value retrieved is given by <code>T</code>, which may be <code>Nullable{T}</code>. Optionally provided is the <code>schema</code> (the same <code>schema</code> that is passed in the <code>MyPkg.Sink(schema, ...)</code> constructors). This argument is passed for efficiency since</li>
</ul>
<p>it can be calculated once at the beginning of a <code>Data.stream!</code> and used quickly for many calls to <code>Data.streamto!</code>. This argument is optional, because a Sink can overload <code>Data.streamto!</code> with or without it.</p>
<p>A <code>Data.Sink</code> supports <strong>column-based</strong> streaming by defining:</p>
<pre><code>* `Data.streamto!{T}(sink::MyPkg.Sink, ::Type{Data.Column}, column::Type{T}, row, col[, schema])`: Given a column number `col` and column of data `column`, a `Data.Sink` should store it appropriately. The type of the column is given by `T`, which may be a `NullableVector{T}`. Optionally provided is the `schema` (the same `schema` that is passed in the `MyPkg.Sink(schema, ...)` constructors). This argument is passed for efficiency since it can be calculated once at the beginning of a `Data.stream!` and used quickly for many calls to `Data.streamto!`. This argument is optional, because a Sink can overload `Data.streamto!` with or without it.
</code></pre>

<p>A <code>Data.Sink</code> can optionally define the following if needed:</p>
<ul>
<li><code>Data.cleanup!(sink::MyPkg.Sink)</code>: certain <code>Data.Sink</code>, like databases, may need to protect against inconvenient or dangerous "states" if there happens to be an error while streaming. <code>Data.cleanup!</code> provides the sink a way to rollback a transaction or other kind of cleanup if an error occurs during streaming</li>
<li><code>Data.close!(sink::MyPkg.Sink)</code>: during the <code>Data.stream!</code> workflow, a <code>Data.Sink</code> should remain "open" to receiving data until <code>Data.close!</code> is call explicitly. <code>Data.close!</code> is defined to allow a sink to fully commit all streaming results and close/destroy any necessary resources.</li>
</ul>
<p><a id='Data.Schema-1'></a></p>
<h2 id="dataschema"><code>Data.Schema</code></h2>
<p><a id='DataStreams.Data.Schema' href='#DataStreams.Data.Schema'>#</a>
<strong><code>DataStreams.Data.Schema</code></strong> &mdash; <em>Type</em>.</p>
<p>A <code>Data.Schema</code> describes a tabular dataset (i.e. a set of optionally named, typed columns with records as rows)</p>
<p><code>Data.Schema</code> allow <code>Data.Source</code> and <code>Data.Sink</code> to talk to each other and prepare to provide/receive data through streaming. <code>Data.Schema</code> fields include:</p>
<ul>
<li>A boolean type parameter that indicates whether the # of rows is known in the <code>Data.Source</code>; this is useful as a type parameter to allow <code>Data.Sink</code> and <code>Data.streamto!</code> methods to dispatch. Note that the sentinel value <code>-1</code> is used as the # of rows when the # of rows is unknown.</li>
<li><code>Data.header(schema)</code> to return the header/column names in a <code>Data.Schema</code></li>
<li><code>Data.types(schema)</code> to return the column types in a <code>Data.Schema</code>; <code>Nullable{T}</code> indicates columns that may contain missing data (null values)</li>
<li><code>Data.size(schema)</code> to return the (# of rows, # of columns) in a <code>Data.Schema</code></li>
</ul>
<p><code>Data.Source</code> and <code>Data.Sink</code> interfaces both require that <code>Data.schema(source_or_sink)</code> be defined to ensure that other <code>Data.Source</code>/<code>Data.Sink</code> can work appropriately.</p>
<p><a target='_blank' href='https://github.com/JuliaData/DataStreams.jl/tree/53521cb03de5e24ab9b509e05eac49b58dce7aaf/src/DataStreams.jl#L17-L30' class='documenter-source'>source</a><br></p>
          <aside class="copyright" role="note">
            
            Documentation built with
            <a href="http://www.mkdocs.org" target="_blank">MkDocs</a>
            using the
            <a href="http://squidfunk.github.io/mkdocs-material/" target="_blank">
              Material
            </a>
            theme.
          </aside>
          
            <footer class="footer">
              
            </footer>
          
        </div>
      </article>
      <div class="results" role="status" aria-live="polite">
        <div class="scrollable">
          <div class="wrapper">
            <div class="meta"></div>
            <div class="list"></div>
          </div>
        </div>
      </div>
    </main>
    <script>
      var base_url = '.';
      var repo_id  = 'JuliaData/DataStreams.jl';
    </script>
    <script src="./assets/javascripts/application-997097ee0c.js"></script>
    
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
      <script src="./assets/mathjaxhelper.js"></script>
    
    
  </body>
</html>