{
    "docs": [
        {
            "location": "/", 
            "text": "DataStreams.jl\n\n\nThe \nDataStreams.jl\n package aims to define a generic and performant framework for the transfer of \"table-like\" data. (i.e. data that can, in some sense, be described by rows and columns).\n\n\nThe framework achieves this by defining a system of \nData.Source\n types and methods to describe how they \"provide\" data; as well as \nData.Sink\n types and methods around how they \"receive\" data. This allows \nData.Source\ns and \nData.Sink\ns to implement their interfaces separately, without needing to be aware of each other. The end result is an ecosystem of packages that \"automatically\" talk with each other, with adding an additional package requiring no additional machinery in an existing packages.\n\n\n\n\nData.Source\n Interface\n\n\nThe \nData.Source\n interface requires the following definitions, where \nMyPkg\n would represent a package wishing to implement the framework:\n\n\n\n\nData.schema(::MyPkg.Source) =\n Data.Schema\n; get the \nData.Schema\n of a \nData.Source\n. Typically the \nSource\n type will store the \nData.Schema\n directly, but this isn't strictly required. See \n?Data.Schema\n or docs below for more information on \nData.Schema\n\n\nData.isdone(::MyPkg.Source, row, col) =\n Bool\n; indicates whether the \nData.Source\n will be able to provide data, given a \nrow\n and \ncol\n.\n\n\n\n\nOptional definition:\n\n\n\n\nData.reference(::MyPkg.Source) =\n Vector{UInt8}\n; Sometimes, a \nSource\n needs the \nSink\n to keep a reference to memory to keep a data structure valid. A \nSource\n can implement this method to return a \nVector{UInt8}\n that the \nSink\n will need to handle appropriately.\n\n\n\n\nA \nData.Source\n also needs to \"register\" the type (or types) of streaming it supports. Currently defined streaming types in the DataStreams framework include:\n\n\n\n\nData.Field\n: a field is the intersection of a specific row and column; this type of streaming will traverse the \"table\" structure by row, accessing each column on each row\n\n\nData.Column\n: this type of streaming will provide entire columns at a time\n\n\n\n\nA \nData.Source\n \"registers\" to support field-based streaming by defining the following:\n\n\n\n\nData.streamtype(::Type{MyPkg.Source}, ::Type{Data.Field}) = true\n; declares that \nMyPkg.Source\n supports field-based streaming\n\n\nData.getfield{T}(::MyPkg.Source, ::Type{T}, row, col) =\n Nullable{T}\n; returns a value of type \nNullable{T}\n given a specific \nrow\n and \ncol\n from \nMyPkg.Source\n\n\n\n\nAnd for column-based streaming:\n\n\n\n\nData.streamtype(::Type{MyPkg.Source}, ::Type{Data.Column}) = true\n\n\nData.getcolumn{T}(::Data.Source, ::Type{T}, col) =\n AbstractVector{T}\n\n\n\n\n\n\nData.Sink\n Interface\n\n\nSimilar to a \nData.Source\n, a \nData.Sink\n needs to \"register\" the types of streaming it supports, it does so through the following definition:\n\n\n\n\nData.streamtypes(::Type{MyPkg.Sink}) = [Data.Field[, Data.Column]]\n; \"registers\" the streaming preferences for \nMyPkg.Sink\n. A \nSink\n type should list the stream type or types it supports. If the \nSink\n supports streaming of multiple types, it should list them in order of preference (i.e. the more natural or performant type first).\n\n\n\n\nA \nData.Sink\n should also implement specific forms of constructors that allow convenience in many higher-level streaming functions:\n\n\n\n\nMyPkg.Sink{T \n: Data.StreamType}(source, ::Type{T}, append::Bool, args...)\n; given an instance of a \nData.Source\n, the type of streaming \nT\n, whether the user desires to append \nsource\n or not, and any necessary \nargs...\n, construct an appropriate instance of \nMyPkg.Sink\n ready to receive data from \nsource\n.\n\n\nMyPkg.Sink{T \n: Data.StreamType}(sink, source, ::Type{T}, append::Bool)\n; similar to above, but instead of constructing a new \nSink\n, an existing \nSink\n is given as a first argument, which may be modified before being returned, ready to receive data from \nsource\n.\n\n\n\n\nAnd finally, a \nData.Sink\n needs to implement the meat of the framework, the actual streaming method. For a \nSink\n supporting field-based streaming, the following method should be defined:\n\n\n\n\nData.stream!(source, ::Type{Data.Field}, sink::MyPkg.Sink, append::Bool)\n; given a generic \nData.Source\n, continue streaming data until \nData.isdone(source, row, col) == true\n. The streaming method should usually check \nData.isdone(source, 1, 1) \n return sink\n before starting the actual streaming to account for a potentially empty \nData.Source\n.\n\n\n\n\nAnd for column-based streaming:\n\n\n\n\nData.stream!(source, ::Type{Data.Column}, sink::MyPkg.Sink, append::Bool)", 
            "title": "Home"
        }, 
        {
            "location": "/#datastreamsjl", 
            "text": "The  DataStreams.jl  package aims to define a generic and performant framework for the transfer of \"table-like\" data. (i.e. data that can, in some sense, be described by rows and columns).  The framework achieves this by defining a system of  Data.Source  types and methods to describe how they \"provide\" data; as well as  Data.Sink  types and methods around how they \"receive\" data. This allows  Data.Source s and  Data.Sink s to implement their interfaces separately, without needing to be aware of each other. The end result is an ecosystem of packages that \"automatically\" talk with each other, with adding an additional package requiring no additional machinery in an existing packages.", 
            "title": "DataStreams.jl"
        }, 
        {
            "location": "/#datasource-interface", 
            "text": "The  Data.Source  interface requires the following definitions, where  MyPkg  would represent a package wishing to implement the framework:   Data.schema(::MyPkg.Source) =  Data.Schema ; get the  Data.Schema  of a  Data.Source . Typically the  Source  type will store the  Data.Schema  directly, but this isn't strictly required. See  ?Data.Schema  or docs below for more information on  Data.Schema  Data.isdone(::MyPkg.Source, row, col) =  Bool ; indicates whether the  Data.Source  will be able to provide data, given a  row  and  col .   Optional definition:   Data.reference(::MyPkg.Source) =  Vector{UInt8} ; Sometimes, a  Source  needs the  Sink  to keep a reference to memory to keep a data structure valid. A  Source  can implement this method to return a  Vector{UInt8}  that the  Sink  will need to handle appropriately.   A  Data.Source  also needs to \"register\" the type (or types) of streaming it supports. Currently defined streaming types in the DataStreams framework include:   Data.Field : a field is the intersection of a specific row and column; this type of streaming will traverse the \"table\" structure by row, accessing each column on each row  Data.Column : this type of streaming will provide entire columns at a time   A  Data.Source  \"registers\" to support field-based streaming by defining the following:   Data.streamtype(::Type{MyPkg.Source}, ::Type{Data.Field}) = true ; declares that  MyPkg.Source  supports field-based streaming  Data.getfield{T}(::MyPkg.Source, ::Type{T}, row, col) =  Nullable{T} ; returns a value of type  Nullable{T}  given a specific  row  and  col  from  MyPkg.Source   And for column-based streaming:   Data.streamtype(::Type{MyPkg.Source}, ::Type{Data.Column}) = true  Data.getcolumn{T}(::Data.Source, ::Type{T}, col) =  AbstractVector{T}", 
            "title": "Data.Source Interface"
        }, 
        {
            "location": "/#datasink-interface", 
            "text": "Similar to a  Data.Source , a  Data.Sink  needs to \"register\" the types of streaming it supports, it does so through the following definition:   Data.streamtypes(::Type{MyPkg.Sink}) = [Data.Field[, Data.Column]] ; \"registers\" the streaming preferences for  MyPkg.Sink . A  Sink  type should list the stream type or types it supports. If the  Sink  supports streaming of multiple types, it should list them in order of preference (i.e. the more natural or performant type first).   A  Data.Sink  should also implement specific forms of constructors that allow convenience in many higher-level streaming functions:   MyPkg.Sink{T  : Data.StreamType}(source, ::Type{T}, append::Bool, args...) ; given an instance of a  Data.Source , the type of streaming  T , whether the user desires to append  source  or not, and any necessary  args... , construct an appropriate instance of  MyPkg.Sink  ready to receive data from  source .  MyPkg.Sink{T  : Data.StreamType}(sink, source, ::Type{T}, append::Bool) ; similar to above, but instead of constructing a new  Sink , an existing  Sink  is given as a first argument, which may be modified before being returned, ready to receive data from  source .   And finally, a  Data.Sink  needs to implement the meat of the framework, the actual streaming method. For a  Sink  supporting field-based streaming, the following method should be defined:   Data.stream!(source, ::Type{Data.Field}, sink::MyPkg.Sink, append::Bool) ; given a generic  Data.Source , continue streaming data until  Data.isdone(source, row, col) == true . The streaming method should usually check  Data.isdone(source, 1, 1)   return sink  before starting the actual streaming to account for a potentially empty  Data.Source .   And for column-based streaming:   Data.stream!(source, ::Type{Data.Column}, sink::MyPkg.Sink, append::Bool)", 
            "title": "Data.Sink Interface"
        }
    ]
}