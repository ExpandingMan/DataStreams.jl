<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · DataStreams.jl documentation</title><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script></head><body><nav class="toc"><h1>DataStreams.jl</h1><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Data.Source-Interface-1"><code>Data.Source</code> Interface</a></li><li><a class="toctext" href="#Data.Sink-Interface-1"><code>Data.Sink</code> Interface</a></li><li><a class="toctext" href="#Data.Schema-1"><code>Data.Schema</code></a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaData/DataStreams.jl/tree/090d6b6d27f6af6b78464dea19eb51a0981c99c0/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="DataStreams.jl-1" href="#DataStreams.jl-1">DataStreams.jl</a></h1><p>The <code>DataStreams.jl</code> package aims to define a generic and performant framework for the transfer of &quot;table-like&quot; data. (i.e. data that can, at least in some sense, be described by rows and columns).</p><p>The framework achieves this by defining interfaces (i.e. a group of methods) for <code>Data.Source</code> types and methods to describe how they &quot;provide&quot; data; as well as <code>Data.Sink</code> types and methods around how they &quot;receive&quot; data. This allows <code>Data.Source</code>s and <code>Data.Sink</code>s to implement their interfaces separately, without needing to be aware of each other. The end result is an ecosystem of packages that &quot;automatically&quot; talk with each other, with adding an additional package not requiring changes to existing packages.</p><p>Packages can have a single julia type implement both the <code>Data.Source</code> and <code>Data.Sink</code> interfaces, or two separate types can implement them separately. For examples of interface implementations, see some of the packages below:</p><p><code>Data.Source</code> implementations:</p><ul><li><p><a href="https://github.com/JuliaData/CSV.jl/blob/master/src/Source.jl"><code>CSV.Source</code></a></p></li><li><p><a href="https://github.com/JuliaDB/SQLite.jl/blob/master/src/Source.jl"><code>SQLite.Source</code></a></p></li><li><p><a href="https://github.com/JuliaData/DataStreams.jl/blob/master/src/DataStreams.jl#L251"><code>DataFrame</code></a></p></li><li><p><a href="https://github.com/JuliaDB/ODBC.jl/blob/master/src/Source.jl"><code>ODBC.Source</code></a></p></li></ul><p><code>Data.Sink</code> implementations:</p><ul><li><p><a href="https://github.com/JuliaData/CSV.jl/blob/master/src/Sink.jl"><code>CSV.Sink</code></a></p></li><li><p><a href="https://github.com/JuliaDB/SQLite.jl/blob/master/src/Sink.jl"><code>SQLite.Sink</code></a></p></li><li><p><a href="https://github.com/JuliaData/DataStreams.jl/blob/master/src/DataStreams.jl#L287"><code>DataFrame</code></a></p></li><li><p><a href="https://github.com/JuliaDB/ODBC.jl/blob/master/src/Sink.jl"><code>ODBC.Sink</code></a></p></li></ul><h2><a class="nav-anchor" id="Data.Source-Interface-1" href="#Data.Source-Interface-1"><code>Data.Source</code> Interface</a></h2><p>The <code>Data.Source</code> interface requires the following definitions, where <code>MyPkg</code> would represent a package wishing to implement the interface:</p><ul><li><p><code>Data.schema(::MyPkg.Source) =&gt; Data.Schema</code>; get the <code>Data.Schema</code> of a <code>Data.Source</code>. Typically the <code>Source</code> type will store the <code>Data.Schema</code> directly, but this isn&#39;t strictly required. See <code>?Data.Schema</code> or docs below for more information on <code>Data.Schema</code></p></li><li><p><code>Data.isdone(::MyPkg.Source, row, col) =&gt; Bool</code>; indicates whether the <code>Data.Source</code> will be able to provide a value at a given a <code>row</code> and <code>col</code>.</p></li></ul><p>Optional definition:</p><ul><li><p><code>Data.reference(::MyPkg.Source) =&gt; Vector{UInt8}</code>; Sometimes, a <code>Source</code> needs the <code>Sink</code> to keep a reference to memory to keep data valid after the <code>Source</code> goes out of scope. A <code>Source</code> can implement this method to return a <code>Vector{UInt8}</code> that the <code>Sink</code> will need to handle appropriately.</p></li><li><p><code>Base.size(::MyPkg.Source[, i]) =&gt; Int</code>; not explicitly required to enable data-streaming, but a <code>Source</code> should generally be able to describe its first 2 dimensions, i.e. # of rows and columns.</p></li></ul><p>A <code>Data.Source</code> also needs to &quot;register&quot; the type (or types) of streaming it supports. Currently defined streaming types in the DataStreams framework include:</p><ul><li><p><code>Data.Field</code>: a field is the intersection of a specific row and column; this type of streaming will traverse the &quot;table&quot; structure by row, accessing each column on each row</p></li><li><p><code>Data.Column</code>: this type of streaming will provide entire columns at a time</p></li></ul><p>A <code>Data.Source</code> formally supports <strong>field-based</strong> streaming by defining the following:</p><ul><li><p><code>Data.streamtype(::Type{MyPkg.Source}, ::Type{Data.Field}) = true</code>; declares that <code>MyPkg.Source</code> supports field-based streaming</p></li><li><p><code>Data.streamfrom{T}(::MyPkg.Source, ::Type{Data.Field}, ::Type{Nullable{T}}, row, col) =&gt; Nullable{T}</code>; returns a value of type <code>Nullable{T}</code> given a specific <code>row</code> and <code>col</code> from <code>MyPkg.Source</code></p></li><li><p><code>Data.streamfrom{T}(::MyPkg.Source, ::Type{Data.Field}, ::Type{T}, row, col) =&gt; T</code>; returns a value of type <code>T</code> given a specific <code>row</code> and <code>col</code> from <code>MyPkg.Source</code></p></li></ul><p>And for column-based streaming:</p><ul><li><p><code>Data.streamtype(::Type{MyPkg.Source}, ::Type{Data.Column}) = true</code>  </p></li><li><p><code>Data.streamfrom{T}(::Data.Source, ::Type{Data.Column}, ::Type{T}, col) =&gt; Vector{T}</code>; Given a type <code>T</code>, returns column # <code>col</code> of a <code>Data.Source</code> as a <code>Vector{T}</code></p></li><li><p><code>Data.streamfrom{T}(::Data.Source, ::Type{Data.Column}, ::Type{Nullable{T}}, col) =&gt; NullableVector{T}</code>; Given a type <code>Nullable{T}</code>, returns column # <code>col</code> of a <code>Data.Source</code> as a <code>NullableVector{T}</code></p></li></ul><h2><a class="nav-anchor" id="Data.Sink-Interface-1" href="#Data.Sink-Interface-1"><code>Data.Sink</code> Interface</a></h2><p>Similar to a <code>Data.Source</code>, a <code>Data.Sink</code> needs to &quot;register&quot; the types of streaming it supports, it does so through the following definition:</p><ul><li><p><code>Data.streamtypes(::Type{MyPkg.Sink}) = [Data.Field[, Data.Column]]</code>; &quot;registers&quot; the streaming preferences for <code>MyPkg.Sink</code>. A <code>Sink</code> type should list the stream type or types it supports. If the <code>Sink</code> supports streaming of multiple types, it should list them in order of preference (i.e. the more natural or performant type first).</p></li></ul><p>A <code>Data.Sink</code> needs to also implement specific forms of constructors that ensure proper Sink state in many higher-level streaming functions:</p><ul><li><p><code>MyPkg.Sink{T &lt;: Data.StreamType}(schema::Data.Schema, ::Type{T}, append::Bool, ref::Vector{UInt8}, args...; kwargs...)</code>; given the <code>schema::Data.Schema</code> of a <code>Data.Source</code>, the type of streaming <code>T</code> (<code>Data.Field</code> or <code>Data.Column</code>), whether the user desires to append the data or not, a possible memory reference <code>ref</code> and any <code>Data.Sink</code> positional <code>args...</code> or keyword arguments <code>kwargs...</code>, construct an appropriate instance of <code>MyPkg.Sink</code> ready to receive data. The <code>append</code> argument allows an already existing sink file/source to &quot;reset&quot; itself if the user does not desire to append.</p></li><li><p><code>MyPkg.Sink{T &lt;: Data.StreamType}(sink, schema::Data.Schema, ::Type{T}, append::Bool, ref::Vector{UInt8})</code>; similar to above, but instead of constructing a new <code>Sink</code>, an existing <code>Sink</code> is given as a first argument, which may be modified before being returned, ready to receive data according to the <code>Data.Source</code> <code>schema</code>. Note that a <code>Data.Sink</code> should modify itself according to the new <code>append</code> and <code>ref</code> arguments as well.</p></li></ul><p>Similar to <code>Data.Source</code>, a <code>Data.Sink</code> also needs to implement it&#39;s own <code>streamto!</code> method that indicates how it receives data.</p><p>A <code>Data.Sink</code> supports <strong>field-based</strong> streaming by defining:</p><ul><li><p><code>Data.streamto!{T}(sink::MyPkg.Sink, ::Type{Data.Field}, val::T, row, col[, schema])</code>: Given a <code>row</code>, <code>col</code>, and <code>val::T</code> a <code>Data.Sink</code> should store the value appropriately. The type of the value retrieved is given by <code>T</code>, which may be <code>Nullable{T}</code>. Optionally provided is the <code>schema</code> (the same <code>schema</code> that is passed in the <code>MyPkg.Sink(schema, ...)</code> constructors). This argument is passed for efficiency since</p></li></ul><p>it can be calculated once at the beginning of a <code>Data.stream!</code> and used quickly for many calls to <code>Data.streamto!</code>. This argument is optional, because a Sink can overload <code>Data.streamto!</code> with or without it. Note that it is appropriate for a <code>Data.Sink</code> to implement specialized <code>Data.streamto!</code> methods that can dispath according to the type <code>T</code> of <code>val::T</code>, although not strictly required.</p><p>A <code>Data.Sink</code> supports <strong>column-based</strong> streaming by defining:</p><pre><code class="language-none">* `Data.streamto!{T}(sink::MyPkg.Sink, ::Type{Data.Column}, column::Type{T}, row, col[, schema])`: Given a column number `col` and column of data `column`, a `Data.Sink` should store it appropriately. The type of the column is given by `T`, which may be a `NullableVector{T}`. Optionally provided is the `schema` (the same `schema` that is passed in the `MyPkg.Sink(schema, ...)` constructors). This argument is passed for efficiency since it can be calculated once at the beginning of a `Data.stream!` and used quickly for many calls to `Data.streamto!`. This argument is optional, because a Sink can overload `Data.streamto!` with or without it.</code></pre><p>A <code>Data.Sink</code> can optionally define the following if needed:</p><ul><li><p><code>Data.cleanup!(sink::MyPkg.Sink)</code>: certain <code>Data.Sink</code>, like databases, may need to protect against inconvenient or dangerous &quot;states&quot; if there happens to be an error while streaming. <code>Data.cleanup!</code> provides the sink a way to rollback a transaction or other kind of cleanup if an error occurs during streaming</p></li><li><p><code>Data.close!(sink::MyPkg.Sink)</code>: during the <code>Data.stream!</code> workflow, a <code>Data.Sink</code> should remain &quot;open&quot; to receiving data until a call to <code>Data.close!</code>. <code>Data.close!</code> is defined to allow a sink to fully commit all streaming results and close/destroy any necessary resources. Note that most convenience functions provided by packages will implicitly call <code>Data.close!</code> after streaming has finished from a single <code>Data.Source</code> to a single <code>Data.Sink</code> (e.g. <code>CSV.read</code>, <code>SQLite.query</code>, <code>Feather.read</code>, <code>ODBC.query</code>, etc.).</p></li></ul><h2><a class="nav-anchor" id="Data.Schema-1" href="#Data.Schema-1"><code>Data.Schema</code></a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStreams.Data.Schema" href="#DataStreams.Data.Schema"><code>DataStreams.Data.Schema</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A <code>Data.Schema</code> describes a tabular dataset (i.e. a set of optionally named, typed columns with records as rows)</p><p><code>Data.Schema</code> allow <code>Data.Source</code> and <code>Data.Sink</code> to talk to each other and prepare to provide/receive data through streaming. <code>Data.Schema</code> fields include:</p><ul><li><p>A boolean type parameter that indicates whether the # of rows is known in the <code>Data.Source</code>; this is useful as a type parameter to allow <code>Data.Sink</code> and <code>Data.streamto!</code> methods to dispatch. Note that the sentinel value <code>-1</code> is used as the # of rows when the # of rows is unknown.</p></li><li><p><code>Data.header(schema)</code> to return the header/column names in a <code>Data.Schema</code></p></li><li><p><code>Data.types(schema)</code> to return the column types in a <code>Data.Schema</code>; <code>Nullable{T}</code> indicates columns that may contain missing data (null values)</p></li><li><p><code>Data.size(schema)</code> to return the (# of rows, # of columns) in a <code>Data.Schema</code></p></li></ul><p><code>Data.Source</code> and <code>Data.Sink</code> interfaces both require that <code>Data.schema(source_or_sink)</code> be defined to ensure that other <code>Data.Source</code>/<code>Data.Sink</code> can work appropriately.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/DataStreams.jl/tree/090d6b6d27f6af6b78464dea19eb51a0981c99c0/src/DataStreams.jl#L13-L26">source</a><br/></section><footer><hr/></footer></article></body></html>
